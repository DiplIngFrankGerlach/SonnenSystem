Import
{
  "Strings.ad",
  "System.ad",
  "Math.ad",
  "PlanetOrSun.ad",
  "AppMain.ad"
}

/*****************************************************************
* Das folgende Programm wurde zu fast 100% von ChatGPT erstellt.
* Es mussten lediglich float/double typen angepasst werden.
*
*****************************************************************/

int Main::main()
{ 
    var PrintfClass pfc;

    // -------------------------------
    // Konstanten
    // -------------------------------
    var Math m;
    var double G = 6.67430e-11f;    // Gravitationskonstante
    var double dt = 60.0f;           // Zeitschritt in Sekunden
    var int steps = 525600;          // Anzahl Zeitschritte

    // -------------------------------
    // Planetendaten
    // -------------------------------
    var double x = 1.5e11f;          // Anfangsposition x (m)
    var double y = 0.0f;             // Anfangsposition y (m)
    var double vx = 0.0f;            // Anfangsgeschwindigkeit vx (m/s)
    var double vy = 30000.0f;        // Anfangsgeschwindigkeit vy (m/s)
    var double massPlanet = 5.972e24f;  // Masse Erde (kg)
    var double massSun = 1.989e30f;     // Masse Sonne (kg)

    // -------------------------------
    // Simulationsschleife
    // -------------------------------
    for(var int i = 0; i < steps; i++)
    {
        // Abstand Erde-Sonne
        var double r = cast(float,m.wurzel(x*x + y*y));

        //pfc.fstr("r=$").sa(r).pr();

        // Gravitationskraft
        var double F = G * massPlanet * massSun / (r*r);
        //pfc.fstr("F=$ mass*mass=$").sa(F).sa(massPlanet * massSun).pr();

        // Beschleunigung
        var double ax = -1.0f * F * x / (r * massPlanet);
        //pfc.fstr("ax=$").sa(ax).pr();


        var double ay = -1.0f * F * y / (r * massPlanet);
        //pfc.fstr("ay=$").sa(ay).pr();

        // Geschwindigkeit aktualisieren
        vx = vx + ax * dt;
        vy = vy + ay * dt;

        // Position aktualisieren
        x = x + vx * dt;
        y = y + vy * dt;

        // Ausgabe der Position
        var double Tage = (i * dt)/(24.0 * 60 * 60);
        pfc.fstr("Step $: Tage: $ x=$, y=$").sa(i).sa(Tage).sa(x).sa(y).pr();
    }
    return 1;
}

/* Code mostly generated by Mistral AI */
void Main::simulateFullSystem()
{
    var PrintfClass pfc;
    pfc.fstr("Solar System Simulation\n").pr();

    var double G = 6.67430e-11;

    // Anzahl der Himmelskörper (Sonne + 8 Planeten + 6 Monde)
    var int numBodies = 15;
    var *PlanetOrSun bodies[] = new PlanetOrSun[numBodies];

    // Astronomische Einheit (AE) in Metern
    var double AU = 1.496e11;

    // Initialisierung der Sonne
    var String_16 sunName("Sun");
    bodies[0].init(sunName, 1.989e30, 696340, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

    // Initialisierung der Planeten (Positionen und Geschwindigkeiten sind vereinfacht)
    // Merkur
    var String_16 mercuryName("Mercury");
    bodies[1].init(mercuryName, 3.3011e23, 2439.7, 0.387 * AU, 0.0, 0.0, 0.0, 47870.0, 0.0);

    // Venus
    var String_16 venusName("Venus");
    bodies[2].init(venusName, 4.8675e24, 6051.8, 0.723 * AU, 0.0, 0.0, 0.0, 35020.0, 0.0);

    // Erde
    var String_16 earthName("Earth");
    bodies[3].init(earthName, 5.972e24, 6371, 1.0 * AU, 0.0, 0.0, 0.0, 29780.0, 0.0);

    // Mond (Erdmond)
    var String_16 moonName("Moon");
    bodies[4].init(moonName, 7.342e22, 1737.4, 1.0 * AU + 384400e3, 0.0, 0.0, 0.0, 29780.0 + 1022.0, 0.0);

    // Mars
    var String_16 marsName("Mars");
    bodies[5].init(marsName, 6.417e23, 3389.5, 1.524 * AU, 0.0, 0.0, 0.0, 24070.0, 0.0);

    // Jupiter
    var String_16 jupiterName("Jupiter");
    bodies[6].init(jupiterName, 1.898e27, 69911, 5.203 * AU, 0.0, 0.0, 0.0, 13060.0, 0.0);

    // Jupitermonde
    // Io
    var String_16 ioName("Io");
    bodies[7].init(ioName, 8.932e22, 1821.6, 5.203 * AU + 421700e3, 0.0, 0.0, 0.0, 13060.0 + 17334.0, 0.0);
    // Europa
    var String_16 europaName("Europa");
    bodies[8].init(europaName, 4.797e22, 1560.8, 5.203 * AU + 671100e3, 0.0, 0.0, 0.0, 13060.0 + 13743.0, 0.0);
    // Ganymed
    var String_16 ganymedeName("Ganymede");
    bodies[9].init(ganymedeName, 1.482e23, 2634.1, 5.203 * AU + 1070400e3, 0.0, 0.0, 0.0, 13060.0 + 10880.0, 0.0);
    // Kallisto
    var String_16 callistoName("Callisto");
    bodies[10].init(callistoName, 1.076e23, 2410.3, 5.203 * AU + 1882700e3, 0.0, 0.0, 0.0, 13060.0 + 8204.0, 0.0);

    // Saturn
    var String_16 saturnName("Saturn");
    bodies[11].init(saturnName, 5.683e26, 58232, 9.582 * AU, 0.0, 0.0, 0.0, 9680.0, 0.0);

    // Titan (Saturnmond)
    var String_16 titanName("Titan");
    bodies[12].init(titanName, 1.345e23, 2574.7, 9.582 * AU + 1221870e3, 0.0, 0.0, 0.0, 9680.0 + 5570.0, 0.0);

    // Uranus
    var String_16 uranusName("Uranus");
    bodies[13].init(uranusName, 8.681e25, 25362, 19.22 * AU, 0.0, 0.0, 0.0, 6800.0, 0.0);

    // Neptun
    var String_16 neptuneName("Neptune");
    bodies[14].init(neptuneName, 1.024e26, 24622, 30.05 * AU, 0.0, 0.0, 0.0, 5430.0, 0.0);

    // Simulationsparameter
    var double dt = 86400; // Zeitschritt: 1 Tag in Sekunden
    var int steps = 365;   // Anzahl der Schritte: 1 Jahr

    // Simulation durchführen
    for (var int step = 0; step < steps; step++)
    {
        // Beschleunigungen und Geschwindigkeiten aktualisieren
        for (var int i = 0; i < numBodies; i++)
        {
            bodies[i].updateVelocity(bodies, numBodies, dt);
        }

        // Positionen aktualisieren
        for (var int i = 0; i < numBodies; i++)
        {
            bodies[i].updatePosition(dt);
        }

        // Fortschritt anzeigen (alle 30 Tage)
        if (step % 30 == 0)
        {
            pfc.fstr("Step $:").sa(step).pr();
            for (var int i = 0; i < numBodies; i++)
            {
                bodies[i].printInfo();
            }
            pfc.fstr("\n").pr();
        }
    }

    return 1;

}



void PlanetOrSun::init(&String_16 pName, double pMass, double pRadius, double pX, double pY, double pZ, double pVx, double pVy, double pVz)
{
    name.assign(pName);
    mass = pMass;
    radius = pRadius;
    x = pX;
    y = pY;
    z = pZ;
    vx = pVx;
    vy = pVy;
    vz = pVz;

    // Gravitationskonstante (m³ kg⁻¹ s⁻²)
    G = 6.67430e-11;
}

void PlanetOrSun::updatePosition(double dt)
{
    x += vx * dt;
    y += vy * dt;
    z += vz * dt;
}

void PlanetOrSun::updateVelocity(*PlanetOrSun bodies[], int numBodies, double dt)
{
    var double ax = 0.0;
    var double ay = 0.0;
    var double az = 0.0;

    for (var int i = 0; i < numBodies; i++)
    {
        if (bodies[i] != thisref)
        {
            var double dx = bodies[i].x - x;
            var double dy = bodies[i].y - y;
            var double dz = bodies[i].z - z;
            var double distance = sqrt(dx * dx + dy * dy + dz * dz);
            var double force = G * mass * bodies[i].mass / (distance * distance + 1e-10); // +1e-10, um Division durch 0 zu vermeiden

            ax += force * dx / distance;
            ay += force * dy / distance;
            az += force * dz / distance;
        }
    }

    vx += ax / mass * dt;
    vy += ay / mass * dt;
    vz += az / mass * dt;
}

void PlanetOrSun::printInfo()
{
    var PrintfClass pfc;
    pfc.fstr("Name: $, Position: ($, $, $) m, Velocity: ($, $, $) m/s")
       .sa(name).sa(x).sa(y).sa(z).sa(vx).sa(vy).sa(vz).pr();
}




